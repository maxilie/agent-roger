import { z } from "zod";

export type TaskType =
  /*
      User creates a new root task.
       */
  | "ROOT"

  /*
      ARBITRARY tasks run logic that spawns other, less complex, 
      tasks in order to to generate a concise and valid output.
  
      A root task runs the same logic as an arbitrary task. The type distinction 
      is only needed for finding root tasks in the database.
      */
  | "ARBITRARY_TASK"
  // awaits semanticContextQueries json {semanticContextQueries: string[]}
  // awaits keywordContextQueries json {keywordContextQueries: string[]}
  // awaits semanticQueryEmbeddings json {semanticQueryEmbeddings: number[][]}
  // awaits rawContext json {rawContext: document[]}
  // awaits summarizeContextChildTaskID's resultData: string as db contextSummary
  // awaits stepsAndSuccessCriteria json {steps: string[], successCriteria: string[]}

  // -- until all children are complete and internalData.stepIdxToSubTaskID.length == numSteps.
  // runs step personalization for next stepIdx with dependency data available in db(internalData.stepIdxToSubTaskID[stepIdx]).resultData; generates sub-task definition and starts it.
  // --

  // awaits summarizeSubTaskOutputsChildTaskID's resultData: string as db subTasksSummary
  // awaits validationSummary string
  // awaits correctiveAction json {shouldPause: boolean, newInput: string, newInitialContextSummary: string}}

  /*
      Context hooks are generated by an LLM. These are distinct ideas, sentences, and
      questions along the lines of, "What do I need to know in order to complete this task?"

      Spawned by ARBITRARY_TASK.
       */
  | "GENERATE_SEMANTIC_CONTEXT_QUERIES"

  /*
    Context hooks are used to generate a list of keywords that are likely to be relevant to the task.

      Spawned by ARBITRARY_TASK.
    */
  | "GENERATE_KEYWORD_CONTEXT_QUERIES"

  /*
    Uses an embedding AI model to vectorize the semantic context query/queries.

      Spawned by ARBITRARY_TASK.
    */
  | "GENERATE_SEMANTIC_QUERY_EMBEDDINGS"

  /*
    Queries the document database using the semantic context query vector(s) and the keywords queries.

    Spawned by ARBITRARY_TASK.
    */
  | "QUERY_FOR_CONTEXT"

  /*
      If rawContext length is <1/6th of the token limit, then an EXECUTE_FUNCTION 
      task (to summarize the context) is spawned and its output returned.
  
      Otherwise, the context is split into overlapping chunks, recursively summarized 
      by new SUMMARIZE_CONTEXT tasks, and the results are merged back into a 
      context with length <1/6th of the token limit.

      Each sub-task's input chunks can be any size, but it always outputs a single summary
      with length <1/6th of the token limit.

      Spawned by ARBITRARY_TASK and SUMMARIZE_CONTEXT.
      */
  | "SUMMARIZE_CONTEXT"
  // await EXECUTE_FUNCTION child, OR
  // await SUMMARIZE_CONTEXT child

  /*
    Uses the LLM to populate 3 fields in the task's internalData: steps, stepDependencies: {idx: idx}, and successCriteria.

    Steps do not necessarily correspond 1-1 with successCriteria, since criteria are for the
    task as a whole.

    Spawned by ARBITRARY_TASK.
    */
  | "GENERATE_STEPS_AND_SUCCESS_CRITERIA"

  /*
     Gives a fine-tuned LLM contextSummary and a step. Receives helpful tips and reminders
     on the user's preferences, based on training data, related to generating a task for the step.

     Spawned by ARBITRARY_TASK.
     */
  | "GENERATE_STEP_PERSONALIZATION"

  /*
    Gives the LLM contextSummary, a step, its corresponding stepPersonalization, and dependencyStepOutput?. 
    Receives a task definition (could be fairly long). Spawns a sub-task. Saves sub-task id to internalData.stepIdxToSubTaskID[stepIdx].

    Remains in this stage until all children are complete and num alive ARBITRARY_TASK children == numSteps.

    Does not spawn generate and spawn a task for a step unless its dependency until the previous sub-task is complete=True or success=False. If a sub-task 
    fails, the ARBITRARY_TASK does NOT spawn the next sub-tasks; it skips to SUMMARIZE_SUB_TASK_OUTPUTS.

    Spawned by ARBITRARY_TASK.
    */
  | "GENERATE_SUB_TASK"

  /*
      Executes a pre-defined function from the task runner, and outputs the function's 
      return value. Before executing, the task runner will make sure that the function 
      is whitelisted by admin. If not, the task will pause for human approval.

      Spawned by any task.
       */
  | "EXECUTE_FUNCTION"

  /*
    Outputs from an ARBITRARY_TASK's sub-tasks are recursively summarized and 
    merged using a similar method as for SUMMARIZE_CONTEXT tasks, except the
    initial chunks are the discrete (non-overlapping, unlike for context) sub-task 
    outputs.
    */
  | "SUMMARIZE_SUB_TASK_OUTPUTS"

  /*
    An ARBITRARY task's final output is put through the LLM to declare it valid 
    according its success criteria, or to explain why it failed.
    
    If validated, the ARBITRARY task will be marked as completed, and its parent task 
    will trigger when all of its other children are also marked as completed.

    If the ARBITRARY task failed, the input, contextSummary, and failure explanation will be saved into 
    the vector db for future tasks to use as context.
    */
  | "VALIDATE_OUTPUT"

  /*
    Asks the LLM either: decide to pause the task or, if the LLM thinks the task can be
    completed, generate a modified input and initialContextSummary for the restarted task.

    For example, the modified input could include "figure out why xx went wrong" in
    addition to the broader task.
    */
  | "DECIDE_CORRECTIVE_ACTION";

/* A d3 node */
export type TaskNode = {
  id: number;
  name: string;
  value: number;
  level: number;
  status: "running" | "success" | "failed" | "paused" | "dead";
  dead: boolean;
  type: TaskType;
  parentID: number;
  idxInSiblingGroup: number;
  descendentIDs: number[];
};

/* A d3 link */
export type TaskLink = {
  source: number;
  target: number;
  targetNode: TaskNode;
};

/* */
export type InternalTaskData = {
  subTaskIDs: number[];
};

export const TASK_SCHEMA = z.object({
  taskID: z.number(),
  paused: z.boolean().default(false),
  success: z.boolean().nullish(),
  dead: z.boolean().default(false),
  parentID: z.number().nullish(),
  timeCreated: z.date().default(() => new Date()),
  timeLastUpdated: z.date().default(() => new Date()),
  taskType: z.string(),
  input: z.object({}).nullish(),
  initialContextSummary: z.string().nullish(),
  generateSubTasksStageIdx: z.number().nullish(),
  semanticContextQueries: z.object({}).nullish(),
  keywordContextQueries: z.object({}).nullish(),
  semanticQueryEmbeddings: z.object({}).nullish(),
  rawContext: z.object({}).nullish(),
  contextSummary: z.string().nullish(),
  stepsAndSuccessCriteria: z.object({}).nullish(),
  summarizeSubTaskOutputsChildTaskID: z.number().nullish(),
  subTasksSummary: z.string().nullish(),
  validationSummary: z.string().nullish(),
  resultData: z.object({}).nullish(),
  runtimeErrors: z.object({}).nullish(),
  stage0Data: z.object({}).nullish(),
  stage1Data: z.object({}).nullish(),
  stage2Data: z.object({}).nullish(),
  stage3Data: z.object({}).nullish(),
  stage4Data: z.object({}).nullish(),
  stage5Data: z.object({}).nullish(),
  stage6Data: z.object({}).nullish(),
  stage7Data: z.object({}).nullish(),
  stage8Data: z.object({}).nullish(),
  stage9Data: z.object({}).nullish(),
  stage10Data: z.object({}).nullish(),
  stage11Data: z.object({}).nullish(),
  stage12Data: z.object({}).nullish(),
  stage13Data: z.object({}).nullish(),
  stage14Data: z.object({}).nullish(),
  stage15Data: z.object({}).nullish(),
  stage16Data: z.object({}).nullish(),
  stage17Data: z.object({}).nullish(),
  stage18Data: z.object({}).nullish(),
  stage19Data: z.object({}).nullish(),
  stage20Data: z.object({}).nullish(),
  stage21Data: z.object({}).nullish(),
  stage22Data: z.object({}).nullish(),
  stage23Data: z.object({}).nullish(),
});

// no ID allowed for a new root task (id is auto-generated by SQL)
export const CREATE_ROOT_TASK_SCHEMA = TASK_SCHEMA.omit({ taskID: true, parentID: true,});

// parent ID needed to create a child task
export const CREATE_CHILD_TASK_SCHEMA = CREATE_ROOT_TASK_SCHEMA.and(z.object({ parentID: z.number() }));